import{N as t,D as e}from"../logger-2598bf05.mjs";import{S as s,a as r,P as i,B as n,c as a}from"../session-b977ce56.mjs";import{s as o,k as c}from"../index-b71998f1.mjs";import{m as l}from"../utils-e6870670.mjs";import"../query-builder-2fcde2f0.mjs";class h extends s{constructor(e,s,r,i){super(s),this.client=e,this.options=r,this.tx=i,this.logger=r.logger??new t}prepareQuery(t,e){return new g(this.client,t.sql,t.params,this.logger,e,this.tx)}batch(t){const e=t.map((t=>{const e=this.dialect.sqlToQuery(t);return{sql:e.sql,args:e.params}}));return this.client.batch(e)}async transaction(t,e){const s=await this.client.transaction(),r=new h(this.client,this.dialect,this.options,s),i=new u(this.dialect,r);try{const e=await t(i);return await s.commit(),e}catch(t){throw await s.rollback(),t}}}class u extends r{async transaction(t){const e=`sp${this.nestedIndex}`,s=new u(this.dialect,this.session,this.nestedIndex+1);await this.session.run(o.raw(`savepoint ${e}`));try{const r=await t(s);return await this.session.run(o.raw(`release savepoint ${e}`)),r}catch(t){throw await this.session.run(o.raw(`rollback to savepoint ${e}`)),t}}}class g extends i{constructor(t,e,s,r,i,n){super(),this.client=t,this.queryString=e,this.params=s,this.logger=r,this.fields=i,this.tx=n}run(t){const e=c(this.params,t??{});this.logger.logQuery(this.queryString,e);const s={sql:this.queryString,args:e};return this.tx?this.tx.execute(s):this.client.execute(s)}all(t){const{fields:e,joinsNotNullableMap:s,logger:r,queryString:i,tx:n,client:a}=this;if(e){return this.values(t).then((t=>t.map((t=>l(e,Array.prototype.slice.call(t).map((t=>function(t){if(t instanceof ArrayBuffer){if("undefined"!=typeof Buffer)return t instanceof Buffer?t:Buffer.from(t);if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);throw new Error("TextDecoder is not available. Please provide either Buffer or TextDecoder polyfill.")}return t}(t))),s)))))}const o=c(this.params,t??{});r.logQuery(i,o);const h={sql:i,args:o};return(n?n.execute(h):a.execute(h)).then((({rows:t})=>t.map((t=>{return e=t,Object.keys(e).reduce(((t,s)=>(Object.prototype.propertyIsEnumerable.call(e,s)&&(t[s]=e[s]),t)),{});var e}))))}get(t){return this.all(t).then((t=>t[0]))}values(t){const e=c(this.params,t??{});this.logger.logQuery(this.queryString,e);const s={sql:this.queryString,args:e};return(this.tx?this.tx.execute(s):this.client.execute(s)).then((({rows:t})=>t))}}function p(t,s={}){const r=new a;let i;!0===s.logger?i=new e:!1!==s.logger&&(i=s.logger);const o=new h(t,r,{logger:i},void 0);return new n(r,o)}export{h as LibSQLSession,u as LibSQLTransaction,g as PreparedQuery,p as drizzle};
//# sourceMappingURL=index.mjs.map
