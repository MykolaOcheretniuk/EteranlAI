import { A as AnyColumn, S as SQL, a as SQLChunk, P as Placeholder, b as SQLWrapper, G as GetColumnData, T as Table, V as View } from './column.d-8b137277.js';
export { o as AnyColumnBuilder, aa as AnyTable, aj as Assume, B as BuildColumn, q as BuildColumns, x as BuildQueryConfig, r as ChangeColumnTableName, w as Chunk, g as Column, C as ColumnBaseConfig, n as ColumnBuilder, h as ColumnBuilderBaseConfig, i as ColumnBuilderConfig, l as ColumnBuilderHKT, j as ColumnBuilderHKTBase, k as ColumnBuilderKind, m as ColumnBuilderRuntimeConfig, c as ColumnConfig, f as ColumnHKT, d as ColumnHKTBase, e as ColumnKind, at as ColumnsSelection, J as DriverValueDecoder, K as DriverValueEncoder, Z as DriverValueMapper, al as DrizzleTypeError, ak as Equal, F as FakePrimitiveParam, E as GetDecoderResult, ao as IfThenElse, I as InferColumnsDataTypes, ad as InferModel, M as MakeColumnConfig, ac as MapColumnName, N as Name, af as OneOrMany, O as OptionalKeyOnly, an as Or, $ as Param, ap as PromiseOf, y as Query, Q as QueryTypingsValue, R as RequiredKeyOnly, u as SelectedFields, s as SelectedFieldsFlat, t as SelectedFieldsFlatFull, v as SelectedFieldsOrdered, a7 as SelectionProxyHandler, ai as Simplify, ah as SimplifyOptions, D as StringChunk, a5 as Subquery, a4 as SubqueryConfig, a8 as TableConfig, ag as Update, p as UpdateCBConfig, U as UpdateColConfig, ae as UpdateSet, a9 as UpdateTableConfig, am as ValueOrArray, as as ViewBaseConfig, W as WithEnum, a6 as WithSubquery, aq as Writable, a3 as fillPlaceholders, ar as getTableColumns, ab as getTableName, L as isDriverValueEncoder, z as isSQLWrapper, H as name, X as noopDecoder, Y as noopEncoder, _ as noopMapper, a0 as param, a2 as placeholder, a1 as sql } from './column.d-8b137277.js';
export { C as ConsoleLogWriter, D as DefaultLogger, a as LogWriter, L as Logger, N as NoopLogger } from './logger.d-37185354.js';
export { Q as QueryPromise } from './query-promise.d-a8af8583.js';

declare function bindIfParam(value: unknown, column: AnyColumn | SQL.Aliased): SQLChunk;
/**
 * Test that two values are equal.
 *
 * Remember that the SQL standard dictates that
 * two NULL values are not equal, so if you want to test
 * whether a value is null, you may want to use
 * `isNull` instead.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made by Ford
 * db.select().from(cars)
 *   .where(eq(cars.make, 'Ford'))
 * ```
 *
 * @see isNull for a way to test equality to NULL.
 */
declare function eq<T>(left: SQL.Aliased<T>, right: T | Placeholder | SQLWrapper | AnyColumn): SQL;
declare function eq<TColumn extends AnyColumn>(left: TColumn, right: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper | AnyColumn): SQL;
/**
 * Test that two values are not equal.
 *
 * Remember that the SQL standard dictates that
 * two NULL values are not equal, so if you want to test
 * whether a value is not null, you may want to use
 * `isNotNull` instead.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars not made by Ford
 * db.select().from(cars)
 *   .where(ne(cars.make, 'Ford'))
 * ```
 *
 * @see isNotNull for a way to test whether a value is not null.
 */
declare function ne<T>(left: SQL.Aliased<T>, right: T | Placeholder | SQLWrapper | AnyColumn): SQL;
declare function ne<TColumn extends AnyColumn>(left: TColumn, right: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper | AnyColumn): SQL;
/**
 * Combine a list of conditions with the `and` operator. Conditions
 * that are equal `undefined` are automatically ignored.
 *
 * ## Examples
 *
 * ```ts
 * db.select().from(cars)
 *   .where(
 *     and(
 *       eq(cars.make, 'Volvo'),
 *       eq(cars.year, 1950),
 *     )
 *   )
 * ```
 */
declare function and(...conditions: (SQL | undefined)[]): SQL | undefined;
/**
 * Combine a list of conditions with the `or` operator. Conditions
 * that are equal `undefined` are automatically ignored.
 *
 * ## Examples
 *
 * ```ts
 * db.select().from(cars)
 *   .where(
 *     or(
 *       eq(cars.make, 'GM'),
 *       eq(cars.make, 'Ford'),
 *     )
 *   )
 * ```
 */
declare function or(...conditions: (SQL | undefined)[]): SQL | undefined;
/**
 * Negate the meaning of an expression using the `not` keyword.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars _not_ made by GM or Ford.
 * db.select().from(cars)
 *   .where(not(inArray(cars.make, ['GM', 'Ford'])))
 * ```
 */
declare function not(condition: SQL): SQL;
/**
 * Test that the first expression passed is greater than
 * the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made after 2000.
 * db.select().from(cars)
 *   .where(gt(cars.year, 2000))
 * ```
 *
 * @see gte for greater-than-or-equal
 */
declare function gt<T>(left: SQL.Aliased<T>, right: T | Placeholder | SQLWrapper | AnyColumn): SQL;
declare function gt<TColumn extends AnyColumn>(left: TColumn, right: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper | AnyColumn): SQL;
/**
 * Test that the first expression passed is greater than
 * or equal to the second expression. Use `gt` to
 * test whether an expression is strictly greater
 * than another.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made on or after 2000.
 * db.select().from(cars)
 *   .where(gte(cars.year, 2000))
 * ```
 *
 * @see gt for a strictly greater-than condition
 */
declare function gte<T>(left: SQL.Aliased<T>, right: T | Placeholder | SQLWrapper | AnyColumn): SQL;
declare function gte<TColumn extends AnyColumn>(left: TColumn, right: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper | AnyColumn): SQL;
/**
 * Test that the first expression passed is less than
 * the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made before 2000.
 * db.select().from(cars)
 *   .where(lt(cars.year, 2000))
 * ```
 *
 * @see lte for greater-than-or-equal
 */
declare function lt<T>(left: SQL.Aliased<T>, right: T | Placeholder | SQLWrapper | AnyColumn): SQL;
declare function lt<TColumn extends AnyColumn>(left: TColumn, right: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper | AnyColumn): SQL;
/**
 * Test that the first expression passed is less than
 * or equal to the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made before 2000.
 * db.select().from(cars)
 *   .where(lte(cars.year, 2000))
 * ```
 *
 * @see lt for a strictly less-than condition
 */
declare function lte<T>(left: SQL.Aliased<T>, right: T | Placeholder | SQLWrapper | AnyColumn): SQL;
declare function lte<TColumn extends AnyColumn>(left: TColumn, right: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper | AnyColumn): SQL;
/**
 * Test whether the first parameter, a column or expression,
 * has a value from a list passed as the second argument.
 *
 * ## Throws
 *
 * The argument passed in the second array can’t be empty:
 * if an empty is provided, this method will throw.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made by Ford or GM.
 * db.select().from(cars)
 *   .where(inArray(cars.make, ['Ford', 'GM']))
 * ```
 *
 * @see notInArray for the inverse of this test
 */
declare function inArray<T>(column: SQL.Aliased<T>, values: (T | Placeholder)[] | Placeholder | SQLWrapper): SQL;
declare function inArray<TColumn extends AnyColumn>(column: TColumn, values: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | Placeholder | SQLWrapper): SQL;
/**
 * Test whether the first parameter, a column or expression,
 * has a value that is not present in a list passed as the
 * second argument.
 *
 * ## Throws
 *
 * The argument passed in the second array can’t be empty:
 * if an empty is provided, this method will throw.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made by any company except Ford or GM.
 * db.select().from(cars)
 *   .where(notInArray(cars.make, ['Ford', 'GM']))
 * ```
 *
 * @see inArray for the inverse of this test
 */
declare function notInArray<T>(column: SQL.Aliased<T>, values: (T | Placeholder)[] | Placeholder | SQLWrapper): SQL;
declare function notInArray<TColumn extends AnyColumn>(column: TColumn, values: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | Placeholder | SQLWrapper): SQL;
/**
 * Test whether an expression is NULL. By the SQL standard,
 * NULL is neither equal nor not equal to itself, so
 * it's recommended to use `isNull` and `notIsNull` for
 * comparisons to NULL.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars that have no discontinuedAt date.
 * db.select().from(cars)
 *   .where(isNull(cars.discontinuedAt))
 * ```
 *
 * @see isNotNull for the inverse of this test
 */
declare function isNull(column: AnyColumn | Placeholder | SQLWrapper): SQL;
/**
 * Test whether an expression is not NULL. By the SQL standard,
 * NULL is neither equal nor not equal to itself, so
 * it's recommended to use `isNull` and `notIsNull` for
 * comparisons to NULL.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars that have been discontinued.
 * db.select().from(cars)
 *   .where(isNotNull(cars.discontinuedAt))
 * ```
 *
 * @see isNull for the inverse of this test
 */
declare function isNotNull(column: AnyColumn | Placeholder | SQLWrapper): SQL;
/**
 * Test whether a subquery evaluates to have any rows.
 *
 * ## Examples
 *
 * ```ts
 * // Users whose `homeCity` column has a match in a cities
 * // table.
 * db
 *   .select()
 *   .from(users)
 *   .where(
 *     exists(db.select()
 *       .from(cities)
 *       .where(eq(users.homeCity, cities.id))),
 *   );
 * ```
 *
 * @see notExists for the inverse of this test
 */
declare function exists(subquery: SQLWrapper): SQL;
/**
 * Test whether a subquery doesn't include any result
 * rows.
 *
 * ## Examples
 *
 * ```ts
 * // Users whose `homeCity` column doesn't match
 * // a row in the cities table.
 * db
 *   .select()
 *   .from(users)
 *   .where(
 *     notExists(db.select()
 *       .from(cities)
 *       .where(eq(users.homeCity, cities.id))),
 *   );
 * ```
 *
 * @see exists for the inverse of this test
 */
declare function notExists(subquery: SQLWrapper): SQL;
/**
 * Test whether an expression is between two values. This
 * is an easier way to express range tests, which would be
 * expressed mathematically as `x <= a <= y` but in SQL
 * would have to be like `a >= x AND a <= y`.
 *
 * Between is inclusive of the endpoints: if `column`
 * is equal to `min` or `max`, it will be TRUE.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made between 1990 and 2000
 * db.select().from(cars)
 *   .where(between(cars.year, 1990, 2000))
 * ```
 *
 * @see notBetween for the inverse of this test
 */
declare function between<T>(column: SQL.Aliased, min: T | Placeholder | SQLWrapper, max: T | Placeholder | SQLWrapper): SQL;
declare function between<TColumn extends AnyColumn>(column: TColumn, min: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper, max: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper): SQL;
/**
 * Test whether an expression is not between two values.
 *
 * This, like `between`, includes its endpoints, so if
 * the `column` is equal to `min` or `max`, in this case
 * it will evaluate to FALSE.
 *
 * ## Examples
 *
 * ```ts
 * // Exclude cars made in the 1970s
 * db.select().from(cars)
 *   .where(notBetween(cars.year, 1970, 1979))
 * ```
 *
 * @see between for the inverse of this test
 */
declare function notBetween<T>(column: SQL.Aliased, min: T | Placeholder | SQLWrapper, max: T | Placeholder | SQLWrapper): SQL;
declare function notBetween<TColumn extends AnyColumn>(column: TColumn, min: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper, max: GetColumnData<TColumn, 'raw'> | Placeholder | SQLWrapper): SQL;
/**
 * Compare a column to a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars with 'Turbo' in their names.
 * db.select().from(cars)
 *   .where(like(cars.name, '%Turbo%'))
 * ```
 *
 * @see ilike for a case-insensitive version of this condition
 */
declare function like(column: AnyColumn, value: string | Placeholder | SQLWrapper): SQL;
/**
 * The inverse of like - this tests that a given column
 * does not match a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars that don't have "ROver" in their name.
 * db.select().from(cars)
 *   .where(notLike(cars.name, '%Rover%'))
 * ```
 *
 * @see like for the inverse condition
 * @see notIlike for a case-insensitive version of this condition
 */
declare function notLike(column: AnyColumn, value: string | Placeholder | SQLWrapper): SQL;
/**
 * Case-insensitively compare a column to a pattern,
 * which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * Unlike like, this performs a case-insensitive comparison.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars with 'Turbo' in their names.
 * db.select().from(cars)
 *   .where(ilike(cars.name, '%Turbo%'))
 * ```
 *
 * @see like for a case-sensitive version of this condition
 */
declare function ilike(column: AnyColumn, value: string | Placeholder | SQLWrapper): SQL;
/**
 * The inverse of ilike - this case-insensitively tests that a given column
 * does not match a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars that don't have "Rover" in their name.
 * db.select().from(cars)
 *   .where(notLike(cars.name, '%Rover%'))
 * ```
 *
 * @see ilike for the inverse condition
 * @see notLike for a case-sensitive version of this condition
 */
declare function notIlike(column: AnyColumn, value: string | Placeholder | SQLWrapper): SQL;

/**
 * Used in sorting, this specifies that the given
 * column or expression should be sorted in ascending
 * order. By the SQL standard, ascending order is the
 * default, so it is not usually necessary to specify
 * ascending sort order.
 *
 * ## Examples
 *
 * ```ts
 * // Return cars, starting with the oldest models
 * // and going in ascending order to the newest.
 * db.select().from(cars)
 *   .orderBy(asc(cars.year));
 * ```
 *
 * @see desc to sort in descending order
 */
declare function asc(column: AnyColumn | SQLWrapper): SQL;
/**
 * Used in sorting, this specifies that the given
 * column or expression should be sorted in descending
 * order.
 *
 * ## Examples
 *
 * ```ts
 * // Select users, with the most recently created
 * // records coming first.
 * db.select().from(users)
 *   .orderBy(desc(users.createdAt));
 * ```
 *
 * @see asc to sort in ascending order
 */
declare function desc(column: AnyColumn | SQLWrapper): SQL;

declare class ColumnAliasProxyHandler<TColumn extends AnyColumn> implements ProxyHandler<TColumn> {
    private table;
    constructor(table: Table | View);
    get(columnObj: TColumn, prop: string | symbol): any;
}
declare class TableAliasProxyHandler<T extends Table | View> implements ProxyHandler<T> {
    private alias;
    private replaceOriginalName;
    constructor(alias: string, replaceOriginalName: boolean);
    get(tableObj: T, prop: string | symbol): any;
}

declare class DrizzleError extends Error {
    constructor(message: string);
    static wrap(error: unknown, message?: string): DrizzleError;
}
declare class TransactionRollbackError extends DrizzleError {
    constructor();
}

export { AnyColumn, ColumnAliasProxyHandler, DrizzleError, GetColumnData, Placeholder, SQL, SQLChunk, SQLWrapper, Table, TableAliasProxyHandler, TransactionRollbackError, View, and, asc, between, bindIfParam, desc, eq, exists, gt, gte, ilike, inArray, isNotNull, isNull, like, lt, lte, ne, not, notBetween, notExists, notIlike, notInArray, notLike, or };
