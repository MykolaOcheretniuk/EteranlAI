import{Pool as e,types as t}from"@neondatabase/serverless";import{N as s,D as r}from"../logger-2598bf05.mjs";import{P as i,a,b as n,d as o,c}from"../session-c891400d.mjs";import{k as l,s as u}from"../index-b71998f1.mjs";import{m as h}from"../utils-e6870670.mjs";import"../query-promise-a65edd44.mjs";import"../query-builder-2fcde2f0.mjs";import"../column-builder-592f0191.mjs";class g extends i{constructor(e,t,s,r,i,a){super(),this.client=e,this.params=s,this.logger=r,this.fields=i,this.rawQuery={name:a,text:t},this.query={name:a,text:t,rowMode:"array"}}execute(e={}){const t=l(this.params,e);this.logger.logQuery(this.rawQuery.text,t);const{fields:s,client:r,rawQuery:i,query:a,joinsNotNullableMap:n}=this;if(!s)return r.query(i,t);return r.query(a,t).then((e=>e.rows.map((e=>h(s,e,n)))))}all(e={}){const t=l(this.params,e);return this.logger.logQuery(this.rawQuery.text,t),this.client.query(this.rawQuery,t).then((e=>e.rows))}values(e={}){const t=l(this.params,e);return this.logger.logQuery(this.rawQuery.text,t),this.client.query(this.query,t).then((e=>e.rows))}}class p extends a{constructor(e,t,r={}){super(t),this.client=e,this.options=r,this.logger=r.logger??new s}prepareQuery(e,t,s){return new g(this.client,e.sql,e.params,this.logger,t,s)}async query(e,t){this.logger.logQuery(e,t);return await this.client.query({rowMode:"array",text:e,values:t})}async queryObjects(e,t){return this.client.query(e,t)}async transaction(t,s={}){const r=this.client instanceof e?new p(await this.client.connect(),this.dialect,this.options):this,i=new w(this.dialect,r);await i.execute(u`begin ${i.getTransactionConfigSQL(s)}`);try{const e=await t(i);return await i.execute(u`commit`),e}catch(e){throw await i.execute(u`rollback`),e}finally{this.client instanceof e&&r.client.release()}}}class w extends n{async transaction(e){const t=`sp${this.nestedIndex+1}`,s=new w(this.dialect,this.session,this.nestedIndex+1);await s.execute(u.raw(`savepoint ${t}`));try{const r=await e(s);return await s.execute(u.raw(`release savepoint ${t}`)),r}catch(e){throw await s.execute(u.raw(`rollback to savepoint ${t}`)),e}}}class y{constructor(e,t,s={}){this.client=e,this.dialect=t,this.options=s,this.initMappers()}createSession(){return new p(this.client,this.dialect,{logger:this.options.logger})}initMappers(){t.setTypeParser(t.builtins.TIMESTAMPTZ,(e=>e)),t.setTypeParser(t.builtins.TIMESTAMP,(e=>e)),t.setTypeParser(t.builtins.DATE,(e=>e))}}function m(e,t={}){const s=new c;let i;!0===t.logger?i=new r:!1!==t.logger&&(i=t.logger);const a=new y(e,s,{logger:i}).createSession();return new o(s,a)}export{y as NeonDriver,g as NeonPreparedQuery,p as NeonSession,w as NeonTransaction,m as drizzle};
//# sourceMappingURL=index.mjs.map
